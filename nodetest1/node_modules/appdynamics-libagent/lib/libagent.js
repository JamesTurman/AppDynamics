/*
 * Copyright (c) AppDynamics, Inc., and its affiliates
 * 2015
 * All Rights Reserved
 */
var nodeVersion = process.versions.node.split('.'),
  isV8NodeVersion = false,
  useDefaultHttp = false,
  http, https;

function loadNativeHttp() {
  http = require('http');
  https = require('https');
}

if (parseInt(nodeVersion[0],10) == 0 && parseInt(nodeVersion[1], 10) <= 8) {
  loadNativeHttp();
  isV8NodeVersion = true;
} else {
  try {
    var requestPackage = require('request');
  } catch(err) {
    useDefaultHttp = true;
    loadNativeHttp();
  }
}
var util = require('util');
var EventEmitter = require('events').EventEmitter;

var native;

var MAX_HTTP_RESPONSE_SIZE = 50 * 1024 * 1024; // 50 MB.
var LOG_FILE_NAME = 'appd_node_agent_%Y_%m_%d__%H_%M_%S.%N.log';
var ENV_FILE_NAME = 'appd_node_agent_env_%Y_%m_%d__%H_%M_%S.%N.log';

function init(nativeExt) {
  if (native) {
    return;
  }

  native = nativeExt;
}

function LibAgent(agent) {
  var self = this;

  var opts = agent.opts;
  var controllerInfo = {
    host: opts.controllerHostName,
    port: opts.controllerPort,
    ssl: opts.controllerSslEnabled || false,
    accountName: opts.accountName || "customer1",
    accountKey: opts.accountAccessKey,
    proxy: {
      hostName: opts.proxyHost,
      port: opts.proxyPort,
      userName: opts.proxyUser,
      password: opts.proxyPasswordFile
    }
  };
  if (controllerInfo.proxy.password) {
    var fs = require('fs');
    controllerInfo.proxy.password = (fs.readFileSync(controllerInfo.proxy.password, 'utf-8')).trim();
  }
  var nativeHTTPClient = opts && opts.nativeHTTPClient;
  if (nativeHTTPClient) {
    if (!('certificateFile' in nativeHTTPClient)) {
      var path = require('path');
      // Note: this needs to be changed if this file is moved in the hierarchy
      var moduleRoot = path.dirname(__dirname);
      nativeHTTPClient.certificateFile = path.resolve(moduleRoot, 'ca-bundle.crt');
    }
    controllerInfo.nativeHTTPClient = nativeHTTPClient;
  }

  var analyticsConfig = opts && opts.analytics;
  var analyticsHost = (analyticsConfig && analyticsConfig.host) ? analyticsConfig.host : (process.env.APPDYNAMICS_ANALYTICS_HOST_NAME || 'localhost');
  var analyticsPort = (analyticsConfig && analyticsConfig.port) ? analyticsConfig.port : (parseInt(process.env.APPDYNAMICS_ANALYTICS_PORT, 10) || 9090);
  var analyticsSSL = (analyticsConfig && analyticsConfig.ssl) ? analyticsConfig.ssl : ((process.env.APPDYNAMICS_ANALYTICS_SSL_ENABLED === 'true') || false);
  var analyticsInfo = {
    host: analyticsHost,
    port: analyticsPort,
    ssl: analyticsSSL
  };
  self.delegate = new Delegate(controllerInfo, analyticsInfo);
  self.agent = agent;

  var agentInfo = {
    appName: opts.applicationName,
    tierName: opts.tierName,
    nodeName: opts.nodeName,
    agentType: 'NODEJS_APP_AGENT'
  };

  var logCfg = {
    'logfiles': opts.logging? opts.logging.logfiles: undefined,
    'rootDir': self.agent.tmpDir,
    'debug': opts.debug
  };

  if (!logCfg.logfiles) {
    // libagent fills in the rest of the fields for the default case
    logCfg.logfiles = [{
      'filename': LOG_FILE_NAME
    }, {
      'filename': ENV_FILE_NAME,
      'channel': 'ENV',
    }];
  }

  var len = logCfg.logfiles.length;
  for (var i = 0; i < len; ++i) {
    var cfg = logCfg.logfiles[i];

    if (opts.debug) {
      if (!cfg.level || cfg.level !== 'TRACE') {
        cfg.level = 'DEBUG';
      }
    }

    if (!cfg.filename) {
      cfg.filename = "appd_node_agent_" + i + ".log";
    }

    var pos = cfg.filename.search('%');
    if (pos == -1 || pos == cfg.filename.length - 1) {
      // this doesn't fix a filename without an extension
      cfg.filename = cfg.filename.replace(/\.([^.]*)$/, ".%N.$1");
    }

    if (!cfg.root_directory) {
      cfg.root_directory = self.agent.tmpDir;
    }
  }

  self.agent = new native.NodeAgent(self.delegate, agentInfo, JSON.stringify(logCfg));
  self.delegate.agent = self;

  self.timeSkew = 0;
}

module.exports = {
  'init': init,
  'LibAgent': LibAgent
};


LibAgent.prototype.registerMetrics = function () {
  return this.agent.registerMetrics();
};

LibAgent.prototype.registerObjects = function () {
  return this.agent.registerObjects();
};

LibAgent.prototype.sendTopSummaryStats = function () {
  return this.agent.sendTopSummaryStats();
};

LibAgent.prototype.sendAnalyticsData = function () {
  return this.agent.sendAnalyticsData();
};

LibAgent.prototype.start = function (meta) {
  return this.agent.start(meta);
};

LibAgent.prototype.updateConfig = function () {
  return this.agent.updateConfig();
};

LibAgent.prototype.stopBusinessTransaction = function (btGuid) {
  this.agent.stopBusinessTransaction(btGuid);
};

LibAgent.prototype.startExitCall = function (btGuid, exitPointType,
                                             exitPointSubType,
                                             category, command, properties) {
  return this.agent.startExitCall(btGuid, exitPointType,
                                  exitPointSubType, category, command, properties);
};

LibAgent.prototype.stopExitCall = function (exitCall, errorName, message) {
  this.agent.stopExitCall(exitCall, errorName, message);
};

LibAgent.prototype.getBusinessTransactionId = function (txnGuid) {
  return this.agent.getBusinessTransactionId(txnGuid);
};

LibAgent.prototype.getUserProcessSnapshotRequest = function() {
  return this.agent.getUserProcessSnapshotRequest();
};

LibAgent.prototype.addIdentifyingPropertyToExitCall = function(exitCall, key, value) {
  this.agent.addIdentifyingPropertyToExitCall(exitCall, key, value);
};

LibAgent.prototype.getBusinessTransactionGuid = function(txn) {
  return this.agent.getBusinessTransactionGuid(txn);
};

// ensure this is kept in sync with LogLevel in agent.h
var LogLevel = {
  TRACE: 0,
  DEBUG: 1,
  INFO: 2,
  WARN: 3,
  ERROR: 4,
  FATAL: 5
};

LibAgent.prototype.logTrace = function (msg) {
  this.agent.log(LogLevel.TRACE, msg);
};

LibAgent.prototype.logDebug = function (msg) {
  this.agent.log(LogLevel.DEBUG, msg);
};

LibAgent.prototype.logInfo = function (msg) {
  this.agent.log(LogLevel.INFO, msg);
};

LibAgent.prototype.logWarn = function (msg) {
  this.agent.log(LogLevel.WARN, msg);
};

LibAgent.prototype.logError = function (msg) {
  this.agent.log(LogLevel.ERROR, msg);
};

LibAgent.prototype.logFatal = function(msg) {
  this.agent.log(LogLevel.FATAL, msg);
};

LibAgent.prototype.logEnv = function(msg) {
  // Add the logger name to it to send it to a different logger.
  this.agent.log(LogLevel.INFO, msg, 'ENV');
};

LibAgent.prototype.checkForSlowRequests = function () {
  this.agent.checkForSlowRequests();
};

LibAgent.prototype.aggregateRuntimeStatistics = function () {
  this.agent.aggregateRuntimeStatistics();
};

LibAgent.prototype.getCorrelationHeader = function (exitCall) {
  return this.agent.getCorrelationHeader(exitCall);
};

LibAgent.prototype.addCustomMetric = function(name, aggregatorType, timeRollup, clusterRollup, holeHandling) {
  return this.agent.addCustomMetric(name, aggregatorType, timeRollup, clusterRollup, holeHandling);
};

LibAgent.prototype.addMetric = function(name, aggregatorType, timeRollup, clusterRollup, holeHandling) {
  return this.agent.addMetric(name, aggregatorType, timeRollup, clusterRollup, holeHandling);
};

LibAgent.prototype.reportMetric = function(metricId, value) {
  return this.agent.reportMetric(metricId, value);
};

LibAgent.prototype.addErrorToTransaction = function(btGuid, name, message, errorCode) {
  return this.agent.addErrorToTransaction(btGuid, name, message, errorCode);
};

LibAgent.prototype.isSnapshotRequired = function(txnGuid) {
  return this.agent.isSnapshotRequired(txnGuid);
};

LibAgent.prototype.setSnapshotRequired = function(txnGuid) {
  this.agent.setSnapshotRequired(txnGuid);
};

LibAgent.prototype.processAndSendSnapshots = function() {
  this.agent.processAndSendSnapshots();
};

LibAgent.prototype.addProcessSnapshot = function (processSnapshot) {
  this.agent.addProcessSnapshot(processSnapshot);
};

LibAgent.prototype.addTransactionSnapshot = function(txnGuid, transactionSnapshot, snapshotData) {
  this.agent.addTransactionSnapshot(txnGuid, transactionSnapshot, snapshotData);
};

LibAgent.prototype.addProcessSnapshotGuid = function(txnGuid, psGuid) {
  this.agent.addProcessSnapshotGuid(txnGuid, psGuid);
};

LibAgent.prototype.addAnalyticsHttpData = function(transaction, callback) {
  this.agent.addAnalyticsHttpData(transaction, callback);
};

LibAgent.prototype.addAnalyticsUserData = function(transaction, userData) {
  this.agent.addAnalyticsUserData(transaction, userData);
};

LibAgent.prototype.updatePeriodicSnapshotTimers = function() {
  this.agent.updatePeriodicSnapshotTimers();
};

LibAgent.prototype.addEvent = function(severity, type, summary, details) {
  return this.agent.addEvent(severity, type, summary, details);
};

LibAgent.prototype.sendEvents = function() {
  return this.agent.sendEvents();
};

LibAgent.prototype.reportOverflows = function() {
  return this.agent.reportOverflows();
};

LibAgent.prototype.processResponses = function() {
  return this.agent.processResponses();
};

LibAgent.prototype.isAgentInitialized = function() {
  return this.agent.isAgentInitialized();
};

LibAgent.prototype.getEumCookieFields = function(txnGuid, shortForm) {
  return this.agent.getEumCookieFields(txnGuid, shortForm);
};

LibAgent.prototype.startBusinessTransaction = function(entryPointType, optionalName, correlationHeader, callback, isHttpRequest) {
  return this.agent.startBusinessTransaction(entryPointType, optionalName, correlationHeader, callback, isHttpRequest);
};

function PendingRequest(httpRequest) {
  this.httpRequest = httpRequest;
}

PendingRequest.prototype.abort = function () {
  this.httpRequest.abort();
};

function Delegate(controllerInfo, analyticsInfo) {
  this.controllerInfo = controllerInfo;
  this.analyticsInfo = analyticsInfo;
  EventEmitter.call(this);
}

util.inherits(Delegate, EventEmitter);

Delegate.prototype.__onResponse = function (request, response, respBody) {
  var self = this;
  var statusCode = response.statusCode | 0; // force status code to be an int.
  if ((statusCode <= 99) || (statusCode >= 1000)) {
    // status code must be a 3 digit integer.
    // If the status code is not a 3 digit integer for some reason
    // convert it to a status code of 500 ( internal server error ).
    statusCode = 500;
  }
  var responseType = ((statusCode != 200) && (statusCode != 202)) ? 'ERROR' : 'SUCCESS';

  var contentLength = response.headers['content-length'] | 0;

  self.agent.logTrace('Delegate Response');
  self.agent.logTrace(JSON.stringify(response.headers, null, "  "));

  if (contentLength < 0) {
    contentLength = 0;
  }
  else if (contentLength > MAX_HTTP_RESPONSE_SIZE) {
    contentLength = MAX_HTTP_RESPONSE_SIZE;
  }

  if (!contentLength) {
    request.onComplete(responseType, statusCode, new Buffer(0));
    return;
  }

  if (respBody) {
    var buffer = new Buffer(respBody);
    request.onComplete(responseType, statusCode, buffer);
    self.emit('response', statusCode, buffer);
  } else {
    var buffers = [];
    var totalSize = 0;
    response.on('data', function (chunk) {
      if (totalSize == contentLength)
        return;

      var newSize = totalSize + chunk.length;
      if (newSize > contentLength) {
        chunk = chunk.slice(0, chunk.length - (contentLength - totalSize));
      }
      buffers.push(chunk);
      totalSize += chunk.length;
    });

    response.on('end', function (){
      var buffer = Buffer.concat(buffers);
      request.onComplete(responseType, statusCode, buffer);
      self.emit('response', statusCode, buffer);
    });
  }
};

Delegate.prototype.__onError = function (request) {
  var self = this;

  var buffer = new Buffer(0);
  request.onComplete('ERROR', 0, buffer);
  self.emit('response', 0, buffer);
};

Delegate.prototype.__doRequest = function(request, options) {
  var self = this;
  self.agent.logTrace("__doRequest: " + request.path);
  var postData = request.postData;
  self.agent.logTrace("__doRequest: " + postData.length.toString());

  try{
      self.agent.logTrace('Delegate Request');
      self.agent.logTrace(JSON.stringify(options, null, "  "));
  }
  catch(err) {
      self.agent.logTrace("__doRequest error: " + err);
  }

  var httpRequest = requestPackage(options, function(err, response, body) {
      if (err) {
          self.__onError(request);
      } else {
          self.__onResponse(request, response, body);
      }
  });

  return new PendingRequest(httpRequest);
};

Delegate.prototype.__doHttpRequest = function(request, options, client) {
  var self = this;
  self.agent.logTrace("__doHttpRequest: " + request.path);
  var postData = request.postData;
  self.agent.logTrace("__doHttpRequest: " + postData.length.toString());

  try{
      self.agent.logTrace('Delegate Request');
      self.agent.logTrace(JSON.stringify(options, null, "  "));
  }
  catch(err) {
      self.agent.logTrace("__doRequestHttpRequest error: " + err);
  }

  var httpRequest = client.request(options, function(response) {
    self.__onResponse(request, response);
  });

  httpRequest.on('error', function (error) {
    self.__onError(request);
  });

  httpRequest.end(postData);
  return new PendingRequest(httpRequest);
}

Delegate.prototype.sendRequest = function (request) {
  var self = this;
  if (request.type == "CONTROLLER") {
    self.agent.logTrace("Controller Request");
    var requestOptions = {
      'appdIgnore': true,
      'method': request.method,
      'headers': {
          'Content-Length': request.postData.length.toString(),
          'Accept': 'application/x-protobuf',
          'Content-Type': 'application/x-protobuf',
      }
    };

    if (isV8NodeVersion || useDefaultHttp) {
      requestOptions['path'] = request.path;
      requestOptions['hostname'] = self.controllerInfo.host;
      requestOptions['port'] = self.controllerInfo.port;
      requestOptions['auth'] = 'singularity-agent@' + self.controllerInfo.accountName +
                      ':' + self.controllerInfo.accountKey;
      return this.__doHttpRequest(request, requestOptions, (self.controllerInfo.ssl) ? https : http);
    }

    requestOptions['url'] = (self.controllerInfo.ssl ? 'https' : 'http') +  '://' + self.controllerInfo.host + ':' + self.controllerInfo.port + (request.path ? request.path : '');
    requestOptions['auth'] = {
      'user': 'singularity-agent@' + self.controllerInfo.accountName,
      'pass': self.controllerInfo.accountKey
    };
    requestOptions['body'] = request.postData;
    requestOptions['encoding'] = null;

    if (self.controllerInfo.proxy.hostName) {
        requestOptions.proxy = 'http://';
        if (self.controllerInfo.proxy.userName && self.controllerInfo.proxy.password) {
            requestOptions.proxy += self.controllerInfo.proxy.userName + ':' + self.controllerInfo.proxy.password + '@' + self.controllerInfo.proxy.hostName + ':' + self.controllerInfo.proxy.port;
        } else {
            requestOptions.proxy += self.controllerInfo.proxy.hostName + ':' + self.controllerInfo.proxy.port;
        }
    }
    return this.__doRequest(request, requestOptions);
  } else if (request.type == "ANALYTICS") {
    self.agent.logTrace("Analytics Request");
    var requestOptions = {
      'appdIgnore': true,
      'method': request.method,
      'headers': {
        'Content-Length': request.postData.length.toString(),
        'Content-Type': 'application/json'
      }
    };

    if (isV8NodeVersion || useDefaultHttp) {
      requestOptions['path'] = request.path;
      requestOptions['hostname'] = self.analyticsInfo.host;
      requestOptions['port'] = self.analyticsInfo.port
      return this.__doHttpRequest(request, requestOptions, (self.analyticsInfo.ssl) ? https : http);
    }

    requestOptions['url'] = (self.analyticsInfo.ssl ? 'https' : 'http') +  '://' + self.analyticsInfo.host + ':' + self.analyticsInfo.port + (request.path ? request.path : '');
    requestOptions['body'] = request.postData;
    requestOptions['json'] = true;
    return this.__doRequest(request, requestOptions);
  } else {
    self.agent.logWarn('Invalid request type ' + request.type);
  }
};

Delegate.prototype.timeSkewChanged = function (timeSkew) {
  this.agent.timeSkew = timeSkew;
  this.agent.logInfo('TimeSkew changed: ' + timeSkew);
};

Delegate.prototype.agentInitialized = function() {
  var self = this;
  self.emit('initialConfigUpdateDone');
};

Delegate.prototype.startProcessSnapshot = function() {
  var self = this;
  self.emit('autoProcessSnapshot');
};

Delegate.prototype.agentReset = function() {
  var self = this;
  self.emit('agentReset');
};

Delegate.prototype.agentDisabled = function() {
  var self = this;
  self.emit('agentDisabled');
};

Delegate.prototype.responsesReady = function() {
  var self = this;
  process.nextTick(function() {
    self.agent.processResponses();
  });
};
