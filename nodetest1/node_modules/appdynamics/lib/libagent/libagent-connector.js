/*

TODO:
report errors similar to exit calls
data collectors
eum
*/


var fs = require('fs');
var util = require('util');
var path = require('path');
var EventEmitter = require('events').EventEmitter;
var ProtobufModel = require('../proxy/protobuf-model').ProtobufModel;
var ExceptionHandlers = require('../core/exception-handlers.js').ExceptionHandlers;
var MessageSender = require('./message-sender').MessageSender;
var Constants = require('./libagent-constants.js');
var Schema;
if(process.env.NODE_ENV != 'appd_test') {
  Schema = require('appdynamics-protobuf').Schema;
}


function toTimeRollup(str) {
  if (str === 'AVG') {
    return Constants.TIME_ROLLUP_AVERAGE;
  }
  else if (str === 'SUM') {
    return Constants.TIME_ROLLUP_SUM;
  }
  else if (str === 'SET') {
    return Constants.TIME_ROLLUP_CURRENT;
  }
  return str;
}

function toClusterRollup(str) {
  if (str === 'INDIVIDUAL') {
    return Constants.CLUSTER_ROLLUP_INDIVIDUAL;
  }
  else if (str === 'COLLECTIVE') {
    return Constants.CLUSTER_ROLLUP_COLLECTIVE;
  }
  return str;
}

function toHoleHandling(str) {
  if (str === 'RATECOUNTER') {
    return Constants.HOLE_HANDLING_RATE_COUNTER;
  }
  else if (str === 'REGULARCOUNTER') {
    return Constants.HOLE_HANDLING_REGULAR_COUNTER;
  }
  return str;
}

function toAggregator(str) {
  if (str === 'AVG') {
    return Constants.AGGREGATOR_AVERAGE;
  }
  else if (str === 'ADVANCED_AVG') {
    return Constants.AGGREGATOR_ADVANCED_AVERAGE;
  }
  else if (str === 'SUM') {
    return Constants.AGGREGATOR_SUM;
  }
  return str;
}

function LibagentConnector(agent) {
  this.agent = agent;
  this.libagent = undefined;
  this.exceptionHandlers = undefined;
  this.isEnabled = false;
  this.minuteTimerId = undefined;
  this.summaryStatsTimerId = undefined;
  this.snapshotTimerId = undefined;
  this.initializationTimerId = undefined;
  this.manualProcessSnapshotInProgress = undefined;
  this.timersInitialized = false;
  EventEmitter.call(this);
}
util.inherits(LibagentConnector, EventEmitter);
exports.LibagentConnector = LibagentConnector;

LibagentConnector.prototype.init = function() {
  var self = this;

  // override libagent-specific definitions in core agent
  self.overrideFunctionDefinitions(self.agent);
  // initialize protobuf
  self.protobufModel = new ProtobufModel(self.agent);
  self.protobufModel.init();
  self.schema = new Schema(fs.readFileSync(path.join(__dirname, '../..', 'conf/protobuf.desc')));


  // initialize protobuf templates
  self.NameValuePair = self.schema['appdynamics.pb.NameValuePair'];
  self.ProcessCallGraphRequest = self.schema['appdynamics.pb.ProcessCallGraphRequest'];
  self.ProcessSnapshot = self.schema['appdynamics.pb.ProcessSnapshot'];
  self.NodejsProcessMetrics = self.schema['appdynamics.pb.NodejsProcessMetrics'];
  self.InstanceTrackingConfig = self.schema['appdynamics.pb.InstanceTrackingConfig'];
  self.InstanceTrackingInfo = self.schema['appdynamics.pb.InstanceTrackingInfo'];
  self.manualProcessSnapshotInProgress = false;

  self.agent.on('agentInitialized', function() {
    var AppdynamicsLibAgent = require('appdynamics-libagent');
    var LibAgent = AppdynamicsLibAgent.LibAgent;
    self.libagent = new LibAgent(self.agent);
    self.exceptionHandlers = new ExceptionHandlers();
    self.exceptionHandlers.init(
      self.agent,
      function() {
        // term handler: libagent needs no teardown
      },
      function() {
        // exception handler: libagent needs no teardown
      });
    self.libagent.delegate.on('initialConfigUpdateDone', function() {
      self.isEnabled = true; // should be API call
      self.initializeTimers();
    });
    self.libagent.delegate.on('agentDisabled', function() {
      self.isEnabled = false;
    });
    self.libagent.delegate.on('agentReset', function() {
      self.agent.metricsManager.init();
    });
  });

  self.agent.on('agentStarted', function(meta) {
    self.libagent.start(meta);
    self.setupEum(self.agent);
    self.emit("connected");

    self.agent.transactionSender.isEnabled = true;
  });
};

LibagentConnector.prototype.startBusinessTransaction = function(entryPointType, optionalName, corrHeader, callback, isHttpRequest) {
  var self = this;

  return self.libagent.startBusinessTransaction(entryPointType, optionalName, corrHeader, callback, isHttpRequest);
};

LibagentConnector.prototype.stopBusinessTransaction = function(transaction) {
  var self = this;

  if (transaction.error) {
    var message = self.protobufModel.extractErrorMessage(transaction.error);
    if (!self.protobufModel.isErrorIgnored(message)) {
      self.libagent.addErrorToTransaction(transaction.btGuid, message, message, transaction.statusCode);
    }
  }

  var btId = self.libagent.getBusinessTransactionId(transaction.btGuid);
  if (btId > 0) {
    self.agent.emit('updateCallContextMap', transaction, btId);
  }
  var psGuids = transaction.processSnapshots;
  if (psGuids) {
    for (var key in psGuids) {
      self.libagent.addProcessSnapshotGuid(transaction.btGuid, key);
    }
  }

  if (transaction.api && transaction.api.analyticsData) {
    var userData = transaction.api.analyticsData;
    self.libagent.addAnalyticsUserData(transaction.btGuid, userData);
  }

  self.libagent.stopBusinessTransaction(transaction.btGuid);
};


LibagentConnector.prototype.startExitCall = function(transaction, exitCall) {
  var self = this;

  var propertiesArray = [];
  for(var propName in exitCall.properties) {
    propertiesArray.push({
      property: propName,
      value: exitCall.properties[propName]
    });
  }

  var category = "";
  if (exitCall.category) {
    category = exitCall.category;
  }

  var command = "";
  if (exitCall.command) {
    command = exitCall.command;
  }

  exitCall.exitCallGuid = self.libagent.startExitCall(
    transaction.btGuid,
    exitCall.exitPointType,
    exitCall.exitPointSubType,
    category,
    command,
    propertiesArray);
  exitCall.correlationHeader = self.libagent.getCorrelationHeader(exitCall.exitCallGuid);
};


LibagentConnector.prototype.stopExitCall = function(exitCall, error) {
  var self = this;

  var errorMessage = null;
  if (error) {
    errorMessage = self.protobufModel.extractErrorMessage(error);
    if (self.protobufModel.isErrorIgnored(errorMessage)) {
      errorMessage = null;
    }
  }
  var errorDetails;
  if (error && error.stack) {
    errorDetails = error.stack;
  }
  else {
    errorDetails = errorMessage;
  }
  self.libagent.stopExitCall(exitCall.exitCallGuid, errorMessage, errorDetails);
};

LibagentConnector.prototype.isSnapshotRequired = function(transaction) {
  var self = this;
  return self.libagent.isSnapshotRequired(transaction.btGuid);
};

LibagentConnector.prototype.sendTopSummaryStats = function() {
  var self = this;
  self.libagent.sendTopSummaryStats();
};

LibagentConnector.prototype.sendTransactionSnapshot = function(transaction, transactionSnapshot) {
  var self = this;

  // fixup exit calls: set all required fields so that the protobuf message remains valid
  if (transactionSnapshot.snapshot.exitCalls) {
    transactionSnapshot.snapshot.exitCalls.forEach(function (item) {
      if (!item.backendIdentifier) {
        item.backendIdentifier = { type: "UNREGISTERED" };
      }
      if (!item.timeTaken) {
        item.timeTaken = 0;
      }
      if (!item.sequenceInfo) {
        item.sequenceInfo = '';
      }
      if (!item.count) {
        item.count = 1;
      }
    });
  }

  var snapshotData = {};
  if (transaction.api && transaction.api.snapshotData) {
    snapshotData.userData = transaction.api.snapshotData;
  }
  self.libagent.addTransactionSnapshot(transaction.btGuid, transactionSnapshot.snapshot, snapshotData);
};

LibagentConnector.prototype.sendProcessSnapshot = function(processSnapshot) {
  var self = this;
  self.libagent.addProcessSnapshot(processSnapshot);
};

LibagentConnector.prototype.registerMetrics = function() {
  var self = this;

  self.libagent.registerMetrics();
};


LibagentConnector.prototype.registerObjects = function() {
  var self = this;

  self.libagent.registerObjects();
};


LibagentConnector.prototype.addMetric = function(name, aggregator, timeRollup) {
  var self = this;
  // All agent-defined metrics use these cluster rollup and hole handling types.
  return self.libagent.addMetric(name, toAggregator(aggregator), toTimeRollup(timeRollup),
                                 Constants.CLUSTER_ROLLUP_INDIVIDUAL,
                                 Constants.HOLE_HANDLING_REGULAR_COUNTER);
};

LibagentConnector.prototype.addCustomMetric = function(name, aggregator, timeRollup, clusterRollup, holeHandling) {
  var self = this;
  return self.libagent.addCustomMetric(name, toAggregator(aggregator), toTimeRollup(timeRollup),
                                       toClusterRollup(clusterRollup), toHoleHandling(holeHandling));
};

LibagentConnector.prototype.reportMetric = function(metricId, value) {
  var self = this;
  return self.libagent.reportMetric(metricId, value);
};

LibagentConnector.prototype.logFatal = function(message) {
  var self = this;
  self.libagent.logFatal(message);
};

LibagentConnector.prototype.logError = function(message) {
  var self = this;
  self.libagent.logError(message);
};

LibagentConnector.prototype.logWarn = function(message) {
  var self = this;
  self.libagent.logWarn(message);
};

LibagentConnector.prototype.logInfo = function(message) {
  var self = this;
  self.libagent.logInfo(message);
};

LibagentConnector.prototype.logDebug = function(message) {
  var self = this;
  self.libagent.logDebug(message);
};

LibagentConnector.prototype.logTrace = function(message) {
  var self = this;
  self.libagent.logTrace(message);
};

LibagentConnector.prototype.logEnv = function(message) {
  var self = this;
  self.libagent.logEnv(message);
};

LibagentConnector.prototype.processAndSendSnapshots = function() {
  var self = this;
  self.libagent.processAndSendSnapshots();
};

LibagentConnector.prototype.getBusinessTransactionId = function (txnGuid) {
  var self = this;
  return self.libagent.getBusinessTransactionId(txnGuid);
};

LibagentConnector.prototype.setSnapshotRequired = function (transaction) {
  var self = this;
  self.libagent.setSnapshotRequired(transaction.btGuid);
};

LibagentConnector.prototype.addEvent = function(severity, type, summary, details) {
  var self = this;

  return self.libagent.addEvent(severity, type, summary, details);
};

LibagentConnector.prototype.sendEvents = function () {
  var self = this;
  self.libagent.sendEvents();
};

LibagentConnector.prototype.handleProcessSnapshotRequest = function () {
  var self = this;

  if (self.manualProcessSnapshotInProgress)
    return;

  var req = self.libagent.getUserProcessSnapshotRequest();
  if (req && req.snapshotRequestID) {
    self.agent.logger.info('process snapshot request', req.snapshotRequestID, 'for duration', req.captureTime);
    self.manualProcessSnapshotInProgress = true;
    self.agent.processScanner.startManualSnapshot(req, function(err, processSnapshot) {
      self.manualProcessSnapshotInProgress = false;
      if (err) {
        self.agent.logger.error(err);
        return;
      }
      self.sendProcessSnapshot(processSnapshot);
    });
  }
};

LibagentConnector.prototype.reportOverflows = function() {
  var self = this;
  self.libagent.reportOverflows();
};

LibagentConnector.prototype.initializeTimers = function() {
  var self = this;

  if (self.timersInitialized) {
    return;
  }
  self.timersInitialized = true;

  self.processMetricTimer = new MessageSender(self.agent, 0 * 1000, 60 * 1000, function() {
    self.agent.metricsManager.getProcessMetrics();
  });

  self.userProcessSnapshotTimerId = new MessageSender(self.agent, 0, 60 * 1000, function() {
    self.handleProcessSnapshotRequest();
  });
};

LibagentConnector.prototype.getEumCookieFields = function(transaction, shortForm) {
  var self = this;
  if (!transaction.ignore)
    return self.libagent.getEumCookieFields(transaction.btGuid, shortForm);
  else
    return {};
};

LibagentConnector.prototype.overrideFunctionDefinitions = function(agent) {
  agent.parseCorrelationInfo = function(source) {
    var self = agent;
    if (typeof(source) === 'object') {
      source = source.headers && source.headers[self.correlation.HEADER_NAME];
    }
    return {
      businessTransactionName: 'NodeJS API Business Transaction',
      headers: {
        'singularityheader': source
      }
    };
  };

  agent.profiler.addExitCall = function(time, exitCall, error) {
    var self = agent.profiler;
    exitCall.error = error;
    var transaction = self.transactions[exitCall.threadId];
    agent.backendConnector.stopExitCall(exitCall, error);
    self.tryEndingTransactionAfterExitCall(transaction, exitCall, time);
  };

  agent.eum.init = function() {
    var self = agent.eum;
    self.registerEumCookieType();
  };

  agent.eum.enabledForTransaction = function(transaction) {
    return !transaction.skip && transaction.eumEnabled;
  };


};

LibagentConnector.prototype.setupEum = function(agent) {
  var libAgentConnector = this;
  agent.eum.eumCookie.prototype.setFieldValues = function() {
    var self = this;
    var shortForm = self.keyForm == 'short';
    var fields = libAgentConnector.getEumCookieFields(self.transaction, shortForm);
    if (fields) {
      for(var key in fields) {
        self.addSubCookie(key, fields[key]);
      }
      self.transaction.eumGuid = fields.g || fields.clientRequestGuid;
      self.guid = self.transaction.eumGuid;
      self.setCookie();
    }
    return true;
  };
};
